## AutoCMP

AutoCMP performs the CMP procedure for parameterized protocols in the Murphi format, and also generates Isabelle proofs verifying correctness of applying the procedure.

For each protocol, the following three input files are required:

1. `<protocol>.m`: description of the parameterized protocol in Murphi format.

2. `abs_process.csv`: information for CMP abstraction and strengthening. Each line records a Murphi rule and the non-interference lemmas which are used for guard strengthening the rule.

3. `auxiliary.m`: the file includes all definitions of auxiliary invariants (non-interference lemmas).

Output files are as follows:

1. The tool `murphiGen` automatically generates the abstract protocol model and auxiliary invariants in the file `ABS<protocol>.m`. This is the finite abstraction of the protocol that can be checked using Murphi model checker.

2. The tool `proofGen` automatically generates a proof script `<protocol>.thy` certificating the correctness of applying the CMP procedure.

## System Architecture

The overall architecture of AutoCMP is shown in the following figure. It uses a Python program `murphiGen` to perform automatic CMP abstraction from protocol description as well as additional CMP information. On the one hand, the abstracted protocol can be model-checked using Murphi. On the other hand, correctness of performing the CMP procedure on the given protocol is verified using an Isabelle script generated by the Python program `proofGen`. The results from model checking and theorem proving are combined together to obtain correctness of the original protocol.

![](./autoCMP.png)

The workflow using AutoCMP on a new example is shown in the following figure. It involves a counterexample-guided refinement loop where auxiliary invariants are added by the human user by examining model checking results from Murphi (it may also be possible to automatically generate auxiliary invariants using machine learning techniques). After sufficient number of auxiliary invariants are found, model checking the abstracted protocol succeeds, and `proofGen` is invoked at the end to generate the Isabelle proof verifying the application of CMP procedure.

![](./autoCMP2.png)

## Requirements

Cmurphi 5.5.0, available at

http://mclab.di.uniroma1.it/site/index.php/software/18-cmurphi

Isabelle2023, available at

https://isabelle.in.tum.de/installation.html

Python 3.11

https://www.python.org/downloads/

Lark 1.1.8, installed using pip:

```bash
pip3 install lark
```

Cmurphi runs on MAC or Linux system. The Python and Isabelle parts runs on Windows, MAC or Linux systems.

## Code Structure

* Basic data structures and utility
  * `murphi.py`: internal representation of Murphi model
  * `isabelle.py`: internal representation of Isabelle definition and proofs
  * `utils.py`: utility functions
* Core procedures
  * `abstract.py`: abstraction and strengthening procedures
  * `generate.py`: some helper functions for CMP abstraction
* Conversion
  * `murphiParser.py`: parser for Murphi model
  * `murphi2isabelle.py`: conversion from Murphi model into Isabelle
* Toplevel
  * `murphiGen.py`: entry point for applying CMP procedure
  * `proofGen.py`: entry point for generating Isabelle proofs
* Examples (each protocol in separate folder)
  * `mutualEx/`: mutual exclusion protocol
  * `mesi/`: mesi protocol
  * `german/`: german protocol
  * `flash/`: flash protocol

## Run an Example

To run AutoCMP on a given protocol, make sure the three files `<protocol>.m`, `auxiliary.m` and `abs_process.csv` are all available in the same directory with name `<protocol>`.

The following command
```bash
python3 murphiGen.py --task <protocol>
```
produces the abstracted protocol according to the CMP procedure. It produces intermediate files `<protocol>_str.json`, and the final abstracted protocol `ABS<protocol>.m` as Murphi file.

To produce the Isabelle proofs verifying the correctness of using CMP for the given protocol, use the following command
```bash
python3 proofGen.py --task <protocol>
```

### `ABS<protocol>.m`

The `ABS<protocol>.m` is an abstraction of the original protocol. It contains the original and abstracted rules, as well as variable definitions, initializations, and invariants, etc. This file is model checked by Murphi, and a positive model checking result should be returned.

### `<protocol>.thy`

`<protocol>.thy` is provided to Isabelle, and should pass Isabelle's proof checking automatically. If both the former model checking result of `ABS<protocol>.m` and the theorem proving result of `<protocol>.thy` are successful, the parameterized protocol is successfully verified. In detail, the Isabelle proof consists of the following parts:

1. Definitions of formally parameterized rules and the initial state of the original protocol under study, which can be directly transformed from the internal model which is in turn compiled from Murphi rules of the protocol. The set of all the parameterized rules are defined in a set ***rules***.

2. Definitions of parameterized invariants ***inv_i*** for strengthening, which are generated by an external oracle or the human user. All invariants used to strengthen a rule ***r*** are collected in an invariant list ***invsFor_r***. All such invariant in lists ***invsFor_r*** are collected in an set ***invS***. Accordingly, we define ***inv'*** for those for observation, and an invariant list ***invs'For_r***, and ***invS'*** accordingly.

3. Definitions of rules ***r_ref*** of the parameterized protocol by strengthening some original protocol rule ***r*** with invariant list ***invsFor_r***, which can be generated in the CMP phase. The set of all the parameterized rules are defined in a set ***rules_ref***.

4. Definitions of rules of the abstracted protocol model, which can be generated in the CMP phase. The set of all the parameterized rules are defined in a set ***ABSrules***.

5. Definitions of the types of variables used in this protocols by a function ***env***. 

6. Lemmas that guaranttees obligations of the symmetry of strengthened rule ***r_ref***, and invariant formulas ***inv_i*** and initial state specification formulas ***init_i***, which is required in obligation in the main theorem.

7. A lemma which guaranttees the obligation which states that ***rules_ref*** is strengthened by ***rules*** with ***invS*** in main theorem. 

8. A lemma which proves the obligation that ***ABSrules(M)*** is indeed the image of the rule abstracting function ***absRuleTranfer*** on the middle set ***rules_ref*** with a cut-off parameter ***M***.  

9. A lemma which proves the obligation that is the correspondence between ***invS*** (invariants for strengthening rules) and ***invS’*** (invariants for observation rules).

10. A lemma which proves the obligation that ***invS’*** (invariants for observation) is safe and well typed by ***env***. In fact, we can furthermore prove that the abstraction results of these invariants is the same as themselves in our case studies.

11. Lemmas which prove that original rules and those in the middle reference protocol (the strengthening result) ***rules_ref*** are well-typed. 

12. A lemma which proves that the initial state specification formulas ***inv_i*** are also well-typed. 

13. The main theorem ***absProtSim*** states the correctness of the parameterized protocol under the assumption that the model checking of the abstracted protocol is positive.

### `<protocol>_str.json`

`<protocol>_str.json` records the abstraction and strengthening instructions of the protocol, used as an intermediate result of the CMP procedure. 

The first item “enum_typs” records elements of type “enum” in the protocol, and the following items contain information about each rule or ruleset. In these items, the first element is the name of a rule or ruleset, and the next are the names of the noninterference lemmas used to strengthen their guard. Note that these lemmas are listed in reverse order of use. 

The third element named “answer”, which is the name of original rule (or ruleset) to distinguish between its abstracted rule. 

The last element, “abstract”, represents abstract information about rules. In this element, “cond” is the signal of parameter information, and when a parameter is false, that parameter is abstracted for this rule. Similarly, “answer” in “abstract” represents the name of the ruleset, except that the name of the abstract ruleset is prefixed or suffixed. Since rules only have global variables that do not need to be abstracted, their terms “strengthen” and “abstract” are empty.

Take the mutualEx protocol as an example: its first item contains its enum type, "state", and then in the last item, "ruleset" means that the ruleset is "Idle" and "strengthening" means that "Lemma_1" is used to strengthen the rule. Its original rule name is "Idle_ref", while its abstract rule name is "ABS_Idle", which are both contained in "answer".

In the other items, the "strengthen" of "Crit" is empty because its abstract form is the same as the original rule and has not been strengthened. "Try" and "Exit" don't exist after abstraction, so the content in "answer" is replaced by "skipRule".
```json
[
    {
        "enum_typs": [
            "state"
        ]
    },
    {
        "ruleset": "Try",
        "strengthen": [],
        "answer": "Try_ref",
        "abstract": [
            {
                "cond": {
                    "i": true
                },
                "answer": "Try_ref"
            },
            {
                "cond": {
                    "i": false
                },
                "answer": "skipRule"
            }
        ]
    },
    {
        "ruleset": "Crit",
        "strengthen": [],
        "answer": "Crit_ref",
        "abstract": [
            {
                "cond": {
                    "i": true
                },
                "answer": "Crit_ref"
            },
            {
                "cond": {
                    "i": false
                },
                "answer": "ABS_Crit"
            }
        ]
    },
    {
        "ruleset": "Exit",
        "strengthen": [],
        "answer": "Exit_ref",
        "abstract": [
            {
                "cond": {
                    "i": true
                },
                "answer": "Exit_ref"
            },
            {
                "cond": {
                    "i": false
                },
                "answer": "skipRule"
            }
        ]
    },
    {
        "ruleset": "Idle",
        "strengthen": [
            "Lemma_1"
        ],
        "answer": "Idle_ref",
        "abstract": [
            {
                "cond": {
                    "i": true
                },
                "answer": "Idle_ref"
            },
            {
                "cond": {
                    "i": false
                },
                "answer": "ABS_Idle"
            }
        ]
    }
]
```

## Model checking using Murphi

We can also model check the abstracted mutualEx protocol with Murphi. For example, for the mutualEx protocol, to convert the (abstracted) Murphi file to C++ program for model checking, use:

```bash
cd mutualEx
mu ABSmutualEx.m
```

Next, compile using g++ to generate `ABSMutualEx.o`:
```bash
g++ -o ABSmutualEx.o ABSmutualEx.cpp -I MURPHI_PATH/include
```
where `MURPHI_PATH` is the path to the Murphi installation.

Finally, run the compiled program:
```bash
./ABSmutualEx.o
```

For larger examples such as the flash protocol, we may want to specify a larger memory limit (4 GB), e.g.:
```bash
./ABSflash.o -m 4096
```

For each command, the output of Murphi should contain "No Error Found" (any warnings can be ignored). The number of states explored for each protocol are also printed:

## Results

The results for our case studies are already in the repository, as the following files:

1. The abstract protocol model in Murphi:

    * mutualEx/AbsmutualEx.m
    * mesi/AbsMesi.m
    * german/AbsGerman.m
    * flash/AbsFlash.m

2. The Isabelle proofs:

    * mutualEx/MutualEx.thy
    * german/German.thy
    * mesi/Mesi.thy
    * flash/Flash.thy

3. By our experiments, we have found some errors in the classical work of CMP field [1].  Please refer to [errors](./SomeErrors.pdf) for details.

[1]: Ching-Tsun Chou, Phanindra K. Mannava, and Seungjoon Park. 2004. A Simple Method for Parameterized Verification of Cache Coherence Protocols. In Proc. 5th International Conference on Formal Methods in Computer-Aided Design (FMCAD’04) (Lecture Notes in Computer Science, Vol. 3312). Springer, 382–398
